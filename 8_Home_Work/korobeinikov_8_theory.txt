0. Шаблон класса — обобщённое описание класса, в котором тип является параметром. Передавая шаблону тип в качесве параметра, можно заставить компилятор сгенерировать класс для этого конкретного типа. Шаблон нужен, чтобы не прописывать вручную один и тот же класс только для разных типов данных.

Важно понимать, что шаблоны не являются определениями классов или функций. Это скорее указания компилятору, как сгенерировать определения класса или функций. Поскольку шаблоны не являются функциями,их нельзя компилировать отдельно, это означает, что определения шаблонных функций-членов нельзя размещать в отдельном файле реализации. Шаблоны необходимо применять совместно с запросами на создание экземпляров шаблонов. Проще всего это сделать, поместив всю информацию о шаблонах в заголовочный файл и включив этот заголовочный файл в файл, использующий шаблоны.

1. Аргументами шаблона могут служить типы, классы или имена каких-то других шаблонов, а также объекты этих трех вещей (т.е. н-р: целые числа или объекты классов). Всё подряд не может служить параметрами шаблона, н-р следующий код является НЕвалидным:

template <typename T1>
class test
{
public:
    int T1() 
    {
        return 0;
    }
    test(){};
    ~test(){};
};

int main()
{
    test<func> a;
    std::cout << a.func();
    return 0;
}

2. Шаблоны можно использовать рекурсивно, н-р так можно создать список стеков, хранящих целые цисла: List <Stack<int>>
Также внутри тела шаблона может быть другой шаблон:

template <typename T1>
class test
{
public:
    template <typename T2>
    int func() 
    {
        T1 a = 2;
        T2 b = 3;
        a += b;
        return a;
    }
    test(){};
    ~test(){};
};

int main()
{
    test<int> a;
    std::cout << a.func<int>(); //выведет 5
    return 0;
}

Разумеется, это всё верно, только если код полученный при замене спецификатора обобщенного типа конкретным типом окажется валидным. (Н-р шаблон написан из предположения, что ему передают класс, а ему передали int).

3. Кол-во эл-ов шаблона — некоторое натуральное число. Других ограничений нет.

4.Возможно задание типизированных параметров шаблона класса по умолчанию. Исторически сложилось, что для шаблонов ф-ций это запрещается по стандарту. Тем не менее, значения по умолчанию нетипизированных параметров можно указывать как для шаблонных классов, так и для шаблонных функций. Ограничения на параметры по умолчанию те же, что и для аргументов ф-ции по умолчанию: после параметра с заданным значением по умолчанию не может идти параметр без значения по умолчанию.

5. Конкретная актуализация шаблона (объявление класса, сгенерированное для конкретного типа) называется созданием экземпляра или специализацией.

Возможны явное и неявное создание экземпляров..
Неявно создаётся экземпляр при созданиия обекта класса, и компилятор генерирует на основе общего шаблона специализированное определение класса. Н-р, при вызове: 
Stack<int> somestack;

Компилятор обеспечивает явное создание экземпляра объявления класса, если класс объявлен с применением ключевого слова template, а также указан необходимый тип или типы. Н-р:
template class Stack<int>;

Явная специализация — задание класса специальным образом для определенного типа. Если класс для определённого набора пераметров описан отдельно, то компилятор не будет создавать новый класс по общему шаблону, а воспользуется отдельным описанием.
Пример явной специализации:
template <> class Stack<int>
{
 …
};

Также возможна частичная специализация, которая частично ограничивает 
общность шаблона. Например, используя частичную специализацию, можно задать 
конкретный тип для одного из параметров типа:
// Общий шаблон
template <typename Tl, typename T2> class Someclass {...};
// Специализация, в которой для Т2 указан тип int
template <typename Tl> class Someclass <Tl, int> {...};
Угловые скобки о, следующие за ключевым словом template, объявляют параметры типов, которые пока еще не специализированы.

6.Ответ: не возможно, т.к. объект myClass не может существовать.
С учётом этого можно реализовать данную программу следующим образом (на сколько понял, подразумевалось, что  ф-ция show дружественная):

#include <cstdlib>
#include <iostream>

template <typename T> void show(T& mc);

template <typename Y>
class myClass
{
private:
    Y a;
public:
    myClass(Y x) : a(x){};
    ~myClass(){};
    friend void show<>(myClass<Y>& mc);
};

template <typename T>
void show(T& mc)
{
    std::cout<< mc.a<< std::endl;
}

int main()
{
    myClass<int> iMc (1);
    myClass<double> dMc (2.5);
    show(iMc);
    show(dMc);
    return 0;
}

7.  Ответ: myClass<int, 100> iMc100 - можно; myClass<int, 1000> iMc1000 -  нельзя, т. к. ф-ция принимает ссылку на  myClass<int, 100>, а iMc1000 не является объектом класса myClass<int, 100>.