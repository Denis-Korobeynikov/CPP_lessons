0. Ключевое слово static - модификатор класса хранения. Он позволяет управлять областью видимости и продолжительностью хранения преременных.
а) Если переменная класса объявлена с использоанием static, то она "становится общей" для 
всех объетов класса. Т.е. при измении значения этой переменной в одном объекте, её значение меняется для всех остальных. Это объясняется тем, что в каждом оъбекте эта переменная ссылается на одну и ту же область памяти.
б) Если преременная объявлена вне ф-ций с ключевым словом static, то она становится видна везде внутри файла, и нигде вне файла. ( так же для ф-ций объявленных со static)
в)  Если преременная объявлена внутри какой-либо ф-ций с ключевым словом static, то она будет видна только внутри этой ф-ции, при этом создана и инициализированна один раз, а память для хранения этой переменной будет выделена в статической области. Пример:
int main()
{
    for (int i = 0; i < 4; ++i) 
    {
        static int counter = i * 2;
        counter++;
        std::cout << counter;
    } // выводит 1234
    std::cout << counter << std::endl; // выдаст ошибку
    return 0;
}

1. Наследование — один из принципов в ООП, означает, что все св-ва предка передаются наследнику. Наследование классов — средство языка, позволяющее передавать возможности одного класса другому. Причины использования: порождение класса с помощью наследования обычно проще и надежнее разработки нового. Надежность обеспечивается тем, что на момент написания класса базовый класс может уже быть многократно проверен.

2. При создании производного класса необходимо указывать базовый клас. Если при объявлении  класса указать базовый класс через ключевое слово public, то будет задано открытое порождение. При открытом порождении открытые члены базового класса становятся открытыми членами производного класса. Закрытые элементы базового класса становятся частью производного класса, однако доступ к ним возможен только через открытые и защищенные методы базового класса.

Производному классу нужны собственные конструкторы. Чтобы получить доступ к закрытым членам базового класса, они должны использовать открытые методы базового класса, в частности, конструкторы базового класса. Когда программа создает объект производного класса, сначала конструируется объект базового класса. Конструктор производного класса должен передавать информацию базового класса конструктору базового класса через список инициализаторов членов. Если в списке инициализаторов членов не предусмотрен конструктор базового класса, программа использует конструктор базового класса по умолчанию.

Уничтожение объектов происходит в порядке, обратном порядку их создания, т.е. сначала выполняется тело деструктора производного класса, а затем автоматически вызывается деструктор базового класса.

Открытое наследование моделирует отношение «является». Это условное
обозначение того, что объект производного класса должен также быть объектом 
базового класса. Все, что можно делать с объектом базового класса, должно быть возможным и для объекта производного класса.

3. Объект производного класса содержит в себе объект базового класса. При этом без явного приведения типов с указателем производного класса можно работать как с указателем на базовый. Тоже верно и для ссылок. Функции, определенные со ссылкой или указателем на базовый класс в качестве аргументов, могут использоваться с объектами как базового, так и производного класса.Свойство совместимости ссылок также позволяет инициализировать объект базового класса значением объекта производного класса.

4. Виртуальные методы объявляются с ключевым словом virtual. Оно определяет, какой метод используется, если метод вызывается не объектом, а ссылкой или указателем. Без ключевого слова virtual программа выбирает метод, основываясь на типе ссылки или указателя. Но если присутствует ключевое слово virtual, программа выбирает метод, основываясь на типе объекта, на который указывает ссылка или указатель.

Если метод объявлен в базовом классе как виртуальный, он автоматически
является виртуальным и в производном классе.

Если планируется переопределять какой-либо метод базового класса в производном классе, то обычно такой метод объявляется в базовом классе как виртуальный.

В базовом классе принято объявлять виртуальный деструктор.

Ключевое слово virtual присутствует только в прототипах методов в объявлении класса, но не в определениях методов.

Имена виртуальных ф-ций обладают динамическим (поздним) связыванием. Это вызвано тем, что во время копиляции не всегда возможно определить, какой метод должен быть вызван.

К виртуальным функциям стоит прибегать только тогда, когда они нужны по
сути задачи.

Конструкторы не могут быть виртуальными.Таким образом, производный класс не наследует конструкторы базового класса, и нет смысла делать их виртуальными.

При переопределении метода скрываются все методы базового класса с тем же именем и любыми сигнатурами аргументов.