0. Типы памяти в С: статическая, куча и стек.
    а) Стек: область видимости — внутри ф-ции, в которой пременная создана; время жизни — до выхода из ф-ции.
    б) Куча (свободное хранилище) : необходима для динамически создаваемых объектов; область видимости — везде внутри программы; время жизни — до тех пор пока напрямую не стерли (н-р: free()).
    в) Статическая: на ней выделяется памятть для переменных с разными типами связывания: внешнее (с возможностью доступа в разных файлах), внутреннее( в одном фале) и без связывания (в пределах одного блока) ; время жизни — до окончания работы программы.
Также в С++11 есть тип памяти для переменных с потоковой продолжительностью хранения.

1. Способы управления областями видимости:
    Фигурные скобочки {} - создаётся новая область видимости.
    Приписать перед объявлением ф-ции / переменной слово static — ограничит область видимости ф-ции / переменной в пределах единицы трансляции.

2. Спецификаторы классов хранения в С++:
    register (явный способ сообщения, что переменная является автоматической)
    static (задаёт внутреннее связывание)
    extern (объявление ссылается на переменную, которая определена в другом месте)
    thread_local (для переменных с потоковой продолжительностью хранения)
    mutable (указывает, что отдельный член структуры может быть изменён даже если переменная типа этой структуры объявлена со спецификатором const)

CV — квалификаторы:
    const (ключевое слово, указывающе, что переменна я не меняет своего значения в ходе выполнения программы)
    volatile (указывает, что содержимое ячейки памяти, на которую указывает переменная, может быть изменено, даже если в программе нет ничего, что могло бы этому поспособствовать)

О пространстве имён:
В С++ представлены средства управления областью видимости имён, которые позволяют избежать конфликта имён. Ключевое слово namespace позволяет новую декларативную область (облсть, где определена переменная). С его помощью можно создавать просранства имён с одинаковыми именами, при этом имена из одного пространства не будут конфликтовать с именами из другого. Пространство имён не может быть помещено в блок,т.к. имена, объявленные в нём имеют по умолчанию внешнее связывание.

Использование: 
namespace space {
name1 ();
}//создали пр-во имён с прототипом ф-ции name1

namespace space {
char name2;
}// добавили ещё одно имя

namespace space {
name1 (){...};
}// определили ф-цию
space::name2 = 0; // использование переменной

using namespace space; // делает доступными внутри файла все имена из space

3. Кличевые слова public и private в классе нужны чтобы отделить интерфейс пользователя (то, с чем взаимодействует программа, использующая объекты класса) от деталей реализации. Как правило в public размещаются функции-члены класса, а в private переменные-члены класса (иногда ф-ции, которые упрощают процесс написания ф-ций из public, но сами по себе не интересны пользователю)
4. Конструктор и деструктор от других методов класса отличает тот факт, что в случае если программа не обнаружит их в объявлении класса, она создаст конструктор и деструктор по умолчанию.
5. new и delete нужны для динамического выделения памяти. Н-р:
    int * a = new int [10] //выдаёт указатель на область памяти, где есть место для хранения массива из 10ти интов
    delete [ ] a // освобождает эту область памяти
Вобщем, улучшенные malloc и free.
6. this — указатель на объект, который использовался для вызова ф-ции члена.
7. std::cout и std::cin — опраторы вывода и ввода в С++ с синтаксисом отличным от printf и scanf.