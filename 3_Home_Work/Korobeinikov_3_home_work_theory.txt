0. Аргумент, являющийся lvalue, представляет собой объект данных, на который можно ссылаться по адресу, rvalue — на который нельзя (rvalue посуществу представляет собой временный объект, который не существует за пределами выражения, которое его создало). Соответственно lvalue ссылка — это ссылка (альтернативное имя) на объект данных, который может быть изменён.  Rvalue ссылка — это ссылка на объект данных, который может находиться только справа от « = », и ему не может быть присвоено никакого значения.
Примеры:

int &val = arg; 
//создание lvalue-ссылки на переменную arg

int &&val = 5 + 5; 
//создание rvalue-ссылки; по факту val — обозначеие для числа 10

1. Список инициализации конструктора — область между сигнатурой и телом конструктора, начинающаяся с двоеточия после « ) » и заканчивающаяся перед символом « { ». В данной области идёт перечисление значений, которые должны будут быть присвоены переменным-членам создаваемого объекта. Необходимость в списках инициализации возникает по причине невозможности присвоения каких-либо значений private-переменным в теле конструктора.

2.Типы конструкторов:

а) Конструктор по умолчнию 
Конструктор без аргументов. (необходим, чтобы задать значения по умолчанию переменным-членам, в случае, если при создании объекта эти значения не будут переданны конструктору). Может быть автоматически сгенерирован компилятором, если не найден никакой другой конструктор. 

б) Конструктор копировния. 
Принимает lvalue-ссылку. Используется при инициализации одного объета другим (но не во время присваивания), н-р, при передаче функции аргументов по значению. Конструктор копирования по умолчанию выполняет почленное копирование нестатических членов, каждый член при этом копируется по значению.

в) Move-конструктор (конструктор премещения).
Принимает rvalue-ccылку. Нужен, чтобы укорять программу. Ускорение происходит за счёт того, что избегается лишний вызов конструктора копирования, в котором происходит копирование больших объёмов данных.

Важно:
В классе существует только один деструктор, и все конструкторы должны быть 
совместимы с ним.
Желательно помимо конструкторов также определить операцию присваивания для объектов класса, принимающую lvalue и rvalue ссылки.

3. Квалификатор const  позволяет сообщить компилятору, что объект данных предназначен только для чтения, т.е. его значение не должно изменяться внутри определённой области (в зависимости от того места в коде, где это ключевое слово написано). В случае, если по ошибке занчение такого объекта данных будет изменено, то компилятор выдаст ошибку.
Причины использования:
а) Использование const защищает от внесения в программы ошибок, приводящих к непреднамеренному изменению данных.
б) Использование const позволяет функции обрабатывать фактические аргументы как с const, так и без const. При этом функция, в прототипе которой квалификатор const опущен, может принимать только неконстантные данные.
в) Использование ссылки const позволяет функции генерировать и использовать временные переменные по мере необходимости.
г) В методах класса добавление сonst в объявлении функции после круглых скобок означет, что вызов данной функции не изменяет состояния объекта.
д) Если возвращаемый тип является const-ссылкой, то он является rvalue.

4.Перегрузка операций — один из примеров полиморфизма С++, позволяет доопределять значения некоторых операций в применении  к пользовательским типам. Перегрузка осуществляется с помощью специальной формы функции: «operator*(список аргументов)», где вместо * вписывается символ прегружаемой операции. (Важно: при перегрузке сохраняется приоритет операций.)

Пример:
В случае сложения двух объетов некоторых классов, следующие записи эквивалентны
с = a + b <=> c = a .operator+(b)
также эквивалентны
d = a + b + c <=> d = a .operator+(b .operator+(c))

Ограничения перегрузки:
а) Перекруженные операции должны иметь в качестве хотябы одного из операндов пользовательский тип.
б) Новая операция должна иметь такой же синтаксис, как у исходной (н-р, нельзя перегрузить +, так чтобы он применялся с одним операндом).
в) Невозможно определить новые символы операций.
г) Существует ряд операций, которые стандарт языка запрещает перегружать.
д) В добавок, при перегрузке операций желательно руководствоваться смысловыми ограничениями. Н-р, не стоит перегружать + так, что он будет удваивать значения переменных, к которым применяется, и возвращать их разность.

5. Ключевое слово friend необходимо, чтобы создать дружественную к данному классу функцию. Для создания такой функции необходимо поместить её прототип в объявлении класса, предварив его словом friend. В определении функции не нужно использовать friend. Данная функция не является членом класса, поэтому обращаться к ней через объекты класса и объявлять с использованием имени класса и «::» не нужно.

6. Отличия new и delete от malloc и free:
а) Синтаксис.
б) В случае, если не найден запрашиваемый объём памяти, new генерирует исключение, malloc  возвращает NULL.
в) Существует разновидность new называемая «new с размещением», которая позволяет указывать адрес используемого блока памяти.
г) При использовании new возможна инициализация при выделении памяти.